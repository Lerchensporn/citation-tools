#!/usr/bin/env python
# -*- coding: utf-8 -*-

# TODO allow for specification of bibtex keyword

"""
Organization of files:
- All references are stores as PDF files.
- The bibliography data are stored in individual files, one file per entry.
	This makes it easy to automatically retrieve and manipulate bibliography
	information with scripts, as well as copy parts of the bibliography.

	The bib file name should be the corresponding reference keyword.

	An alternative would be one large bibtex file that is managed with a GUI program.
	However, it would be difficult to copy selected parts of the bibliography. The
	biggest problem is that it would not be possible to rename or move references without
	breaking the link to the bibliography data.

bib-fetch <file.pdf>
	Print bibliography.
bib-fetch --save <file.pdf>
	Store bibliography.
bib-cite ...
	Look in all subdirectories for bibliography matching the keyword.
bib-cite <keywords> [--style <style>]
	[--order keyword|author|date] [--format plain|html|context|latex]
	Print the CSL-formatted bibliography list of the references specified by the
	keywords.
bib-cite --endnote <keyword> [--style <style>] [--format plain|html|context|latex]
	Print the endnote.
bib-process <filename> [--style <style>] [--format plain|html|context|latex|odf]
	Replace the placeholders "@<key>" and "@bibliography" in the file by the output
	of bib-cite. This is what pandoc already does, but there it is quite broken and
	does not work with context. If not specified, guess the format using a mimetype
	detector. Optionally read the file content from clipboard?

Consider the environment variable BIBSTYLE.
"""

import os
import sys
import warnings
import re
from PyPDF2 import PdfFileReader
import urllib.request
from citeproc.source.bibtex import BibTeX
from citeproc.source.json import CiteProcJSON
from citeproc import CitationStylesStyle, CitationStylesBibliography
from citeproc import formatter
import json
import tempfile
from citeproc import Citation, CitationItem

def bla(bib):
	json_data = [json.loads(bib)]
	json_data[0]["id"] = "id"
	bib_source = CiteProcJSON(json_data)

	"""
	fp, temp_path = tempfile.mkstemp()
	fp.write(bib)
	bib_source = BibTeX(temp_path)
	fp.close()
	"""

	bib_style = CitationStylesStyle('harvard1', validate=False)
	bibliography = CitationStylesBibliography(bib_style, bib_source, formatter.plain)
	for name in sorted(bib_source):
		bibliography.register(Citation([CitationItem(name)]))
	for item in bibliography.bibliography():
		print(str(item))

def doi2bib(doi):
	url = "http://dx.doi.org/" + doi
	headers = {"accept" : "application/json"}
	req = urllib.request.Request(url, headers=headers)
	try:
		resp = urllib.request.urlopen(req)
	except urllib.error.HTTPError as err:
		if err.code == 404:
			print("Invalid DOI: %s" % doi, file=sys.stderr)
		else:
			raise
		return None
	return resp.read().decode(encoding="utf-8")

# pdftotext -f 1 -l 10 -raw "%s" -
def doi_from_file(filename):
	fp = open(filename, "rb")
	with warnings.catch_warnings():
		warnings.simplefilter("ignore")
		pdf = PdfFileReader(fp)
	doigex = re.compile('[\s\.\:]{0,2}(10\.\d{4}[\d\:\.\-\/a-zA-Z]+)[A-Z\s]')
	finds = []
	for i in range(min(10, pdf.getNumPages())):
		text = pdf.getPage(i).extractText().join("/\n")
		finds = doigex.findall(text)
		if len(finds) > 0:
			break
	fp.close()
	if len(finds) == 0:
		return None
	return finds[0]

def main():
	if len(sys.argv) < 2:
		print("Specify a DOI or a file name.")
		return
	if os.path.exists(sys.argv[1]):
		doi = doi_from_file(sys.argv[1])
		if doi is None:
			print("The documents contains no DOI.", file=sys.stderr)
			return
	else:
		doi = sys.argv[1]
	bibtex = doi2bib(doi)
	if bibtex is not None:
		print(bibtex)
	bla(bibtex)
	if "--save" in sys.argv:
		key = key_from_bib()
		fp = open(key, "w")
		fp.close()

if __name__ == "__main__":
	main()
